#include <rclcpp/rclcpp.hpp>
#include <rclcpp_action/rclcpp_action.hpp>

#include <control_msgs/action/gripper_command.hpp>
#include <moveit/move_group_interface/move_group_interface.h>

#include <tf2_ros/transform_listener.h>
#include <tf2_ros/buffer.h>

#include <chrono>
#include <cmath>
#include <thread>
#include <vector>
#include <deque>
#include <algorithm>

using GripperCommand = control_msgs::action::GripperCommand;
using namespace std::chrono_literals;

// NaN/inf 아닌지 체크
static bool isFinite(double v) { return std::isfinite(v); }

// [그리퍼 동작 함수]
// GripperCommand 액션 서버에 "열기/닫기 목표"를 보낸다.

void operateGripper(rclcpp::Node::SharedPtr node,
                    rclcpp_action::Client<GripperCommand>::SharedPtr client,
                    double pos)
{
  // 액션 서버가 살아있는지 2초 대기
  if (!client->wait_for_action_server(2s)) 
  {
    RCLCPP_ERROR(node->get_logger(), "Gripper action server not available");
    return;
  }

  // goal 만들기
  auto goal = GripperCommand::Goal();
  goal.command.position = pos;     // 그리퍼 위치(열기/닫기)
  goal.command.max_effort = 0.5;   // 힘(과도하게 잡는 것 방지)

  // 목표를 비동기로 전송(기다리지 않고 보내기만 함)
  client->async_send_goal(goal);

  // 단순 대기
  rclcpp::sleep_for(800ms);
}

// [FSM 상태 머신]
// 로봇이 어떤 단계인지 "상태"로 구분해서 순서대로 움직이게 하는 방식.
//
// - SEARCH: 마커가 보일 때까지 여기저기 시선/자세를 바꾸며 탐색
// - STABILIZE: 마커가 잠깐 보였다고 바로 달려들면 흔들림/오검출이 있으니
//              몇 번 연속으로 안정적으로 보일 때까지 기다림
// - APPROACH: 마커 위치로 조금씩(step) 다가감
// - GRASP: 그리퍼 닫아서 집기
// - LIFT_AND_HOME: 위로 들어올리고 홈으로 복귀
enum class FSM 
{
  SEARCH,
  STABILIZE,
  APPROACH,
  GRASP,
  LIFT_AND_HOME
};


int main(int argc, char** argv) 
{
  // ROS2 초기화
  rclcpp::init(argc, argv);

  // 노드 생성: 이 노드 이름이 "omx_real_picker"
  auto node = std::make_shared<rclcpp::Node>("omx_real_picker");

  // Gazebo를 쓰면 use_sim_time=true 로 노드들이 통일되어야 한다.
  // 시간 개념이 꼬이면 TF가 "과거/미래"로 튀면서 MoveIt이 멈추거나 플래닝이 깨질 수 있다.
  node->declare_parameter<bool>("use_sim_time", true);

  // ===== [FIX 1] declare만 하면 적용이 안 될 수 있어서 set_parameter로 실제 적용 =====
  bool use_sim_time = node->get_parameter("use_sim_time").as_bool();
  node->set_parameter(rclcpp::Parameter("use_sim_time", use_sim_time));

  // 시스템 안정을 위한 별도의 스레드 
  auto exec = std::make_shared<rclcpp::executors::SingleThreadedExecutor>();
  exec->add_node(node);
  std::thread spinner([&exec](){ exec->spin(); });

  // tf_buffer : TF 데이터를 저장하는 버퍼
  auto tf_buffer = std::make_unique<tf2_ros::Buffer>(node->get_clock());

  // tf_listener : 실제로 /tf 토픽을 구독해서 buffer에 채우는 역할
  auto tf_listener = std::make_shared<tf2_ros::TransformListener>(*tf_buffer);

  // ===== [FIX 2] TF가 buffer에 들어올 시간을 아주 조금 준다(초기 프레임 부재/경고 완화) =====
  rclcpp::sleep_for(300ms);

  // moveit_setup에서 "arm"이라는 planning group을 만든 경우 그걸 제어.
  moveit::planning_interface::MoveGroupInterface arm(node, "arm");
  arm.setMaxVelocityScalingFactor(0.15);

  // 너무 빠른 움직임 방지 (0~1 사이)
  arm.setMaxAccelerationScalingFactor(0.15);

  // 최대 몇 초 동안 해를 찾아보게 할지
  arm.setPlanningTime(5.0);

  // 허용오차
  // position: 3cm 이내면 성공으로 인정
  arm.setGoalPositionTolerance(0.03);
  arm.setGoalOrientationTolerance(3.14);

  // 그리퍼 액션 클라이언트 생성
  // - /gripper_controller/gripper_cmd 라는 액션 서버에 목표를 보낸다.
  auto gripper = rclcpp_action::create_client<GripperCommand>(
    node, "/gripper_controller/gripper_cmd"
  );



  // USER SETTINGS: 환경에 맞게 바꾸는 변수들
  
  // base_frame:
  // 이 노드에서 "목표 위치"를 표현할 기준 좌표계
  // 여기서는 link1 기준으로 마커 위치를 얻고, link1 기준으로 팔을 움직인다.
  std::string base_frame = "link1";

  // target_marker:
  // Python이 TF로 발행하는 마커 프레임 이름
  std::string target_marker = "aruco_marker_23";



  // ✅ (필수) MoveIt이 목표 좌표를 어떤 프레임으로 해석할지 지정
  //
  // 아주 중요:
  // - arm.setPositionTarget(x,y,z)는 "어떤 기준 프레임에서의 x,y,z 인가?"가 필요함.
  arm.setPoseReferenceFrame(base_frame);


  // 탐색용 waypoint(관절각)
  // 로봇이 마커가 보이도록 여러 자세로 이동하면서 "탐색"할 때 쓰는 관절 목표들.
  // arm.setJointValueTarget(waypoints[i]) 로 이동한다.
  std::vector<std::vector<double>> waypoints = 
  {
    { 0.00, -0.20,  0.20,  0.80},
    { 1.00, -0.20,  0.20,  0.80},
    {-1.00, -0.20,  0.20,  0.80},
    { 0.00, -0.60,  0.30,  1.20}
  };

  // 그리퍼 열기/닫기 값
  // - 환경(그리퍼 컨트롤러)에 따라 부호나 범위가 다를 수 있다.
  double GRIP_OPEN  = 0.019;
  double GRIP_CLOSE = -0.001;



  // APPROACH(접근) 관련 파라미터
  // hover_offset : 마커 바로 위에서 시작할 띄우는 거리
  double hover_offset = 0.15;

  // step         : 한 번에 얼마씩 내려가며 접근할지
  double step = 0.03;

  // final_min_z  : 너무 바닥에 박히지 않도록 z 최소값
  double final_min_z = 0.04;


  // TF 신선도 컷
  // - TF가 너무 오래된 값이면 그 위치로 가는 게 위험하니 무시한다.
  double max_tf_age_sec = 2.0;

  // ===== [FIX 4] TF가 순간 끊겨도 마지막 유효 좌표를 잠깐 유지(hold-last) =====
  // - 마커가 0.2~0.8초 정도 끊기는 건 흔해서, 그때마다 SEARCH로 튀면 불안정해진다.
  // - hold_last_sec 동안은 마지막 유효 좌표를 계속 쓰도록 한다.
  node->declare_parameter<double>("hold_last_sec", 1.0);
  double hold_last_sec = node->get_parameter("hold_last_sec").as_double();

  node->declare_parameter<int>("hold_max_cycles", 12);
  int hold_max_cycles = node->get_parameter("hold_max_cycles").as_int();

  // STABILIZE 조건:
  // - 마커가 5번 연속으로 안정적으로 잡히면 "진짜 보인다"고 판단
  int stable_need = 5;

  // APPROACH에서 move 실패가 연속으로 많이 나면 탐색으로 되돌리기
  int max_fail_before_search = 3;

  // median filter(중앙값 필터)
  // FILTER_N=7이면 최근 7개의 값 중 중앙값을 사용한다.
  const size_t FILTER_N = 7;
  std::deque<double> fx, fy, fz;

  auto push_and_median = [&](std::deque<double>& dq, double v) -> double 
  {
    dq.push_back(v);
    if (dq.size() > FILTER_N) dq.pop_front();
    std::vector<double> tmp(dq.begin(), dq.end());
    std::sort(tmp.begin(), tmp.end());
    return tmp[tmp.size()/2];
  };

 
  // INIT: 시작 시 홈으로 가고 그리퍼를 연다
  RCLCPP_INFO(node->get_logger(), ">> HOME");
  arm.setNamedTarget("home"); // MoveIt에서 미리 정의한 home 자세
  arm.move();
  rclcpp::sleep_for(800ms);

  // 그리퍼 열기
  operateGripper(node, gripper, GRIP_OPEN);

  // FSM 초기화
  FSM state = FSM::SEARCH;
  int wp_idx = 0;
  int stable_count = 0;
  int approach_fail = 0;
  double current_offset = hover_offset;

  // 마커 좌표(필터 적용된 값). base_frame(link1) 기준 위치.
  double mx=0, my=0, mz=0;

  // ===== [FIX 4] hold-last 저장소 =====
  bool have_last_good = false;
  double last_good_x = 0.0, last_good_y = 0.0, last_good_z = 0.0;
  rclcpp::Time last_good_time(0, 0, RCL_ROS_TIME);

  // ===== [FIX 3] 프레임이 존재할 때만 canTransform/lookup 시도(Invalid frame 경고 완화) =====
  auto frameExists = [&](const std::string& frame_id) -> bool
  {
    std::vector<std::string> frames;
    tf_buffer->getFrameStrings(frames);
    return std::find(frames.begin(), frames.end(), frame_id) != frames.end();
  };

  // [TF에서 마커 위치를 읽는 함수]
  //
  // 목표:
  // - TF 트리에서 base_frame(link1) -> target_marker(aruco_marker_23)
  //   변환을 가져와서 마커의 (x,y,z)를 얻는다.
  //
  // 왜 TimePointZero인가?
  // - "가장 최신 transform"을 가져오라는 의미.
  // - 특정 시간으로 lookup하면 timestamp mismatch로 오류가 더 자주 난다.
  // ============================================================
  auto getFreshMarker = [&](double& ox, double& oy, double& oz, bool& used_hold) -> bool 
  {
    used_hold = false;

    auto useHoldLast = [&]() -> bool
    {
      if (!have_last_good) return false;
      rclcpp::Time now = node->get_clock()->now();
      double hold_age = (now - last_good_time).seconds();
      if (!std::isfinite(hold_age) || hold_age < 0.0) return false;
      if (hold_age > hold_last_sec) return false;

      ox = last_good_x;
      oy = last_good_y;
      oz = last_good_z;
      used_hold = true;
      return true;
    };

    try 
    {
      // - 프레임 변환이 가능한지 확인 프레임이 존재하지 않으면 false.
      if (!frameExists(base_frame) || !frameExists(target_marker))
      {
        if (useHoldLast()) return true;
        return false;
      }

      if (!tf_buffer->canTransform(base_frame, target_marker, tf2::TimePointZero, 80ms)) 
      {
        if (useHoldLast()) return true;
        return false;
      }

      // 최신 TF 가져오기
      auto t = tf_buffer->lookupTransform(base_frame, target_marker, tf2::TimePointZero);

      // TF의 시간이 너무 오래됐으면 무시
      rclcpp::Time now = node->get_clock()->now();
      rclcpp::Time stamp = t.header.stamp;
      double age = (now - stamp).seconds();

      // age가 음수면 (시간 기준이 꼬였거나 sim_time이 불일치한 상황)
      if (!std::isfinite(age) || age < -0.5) 
      {
        RCLCPP_WARN(node->get_logger(), "TF age invalid (clock mismatch). ignore");
        if (useHoldLast()) return true;
        return false;
      }

      // 너무 오래된 TF면 버림
      if (age > max_tf_age_sec) 
      {
        RCLCPP_WARN(node->get_logger(), "TF too old: %.2fs (ignore)", age);
        if (useHoldLast()) return true;
        return false;
      }

      //  마커 위치(x,y,z)
      double x = t.transform.translation.x;
      double y = t.transform.translation.y;
      double z = t.transform.translation.z;

      //  값이 이상하면 버림
      if (!isFinite(x) || !isFinite(y) || !isFinite(z)) 
      {
        if (useHoldLast()) return true;
        return false;
      }

      //  튐 방지를 위해 median filter 적용
      ox = push_and_median(fx, x);
      oy = push_and_median(fy, y);
      oz = push_and_median(fz, z);

      have_last_good = true;
      last_good_x = ox;
      last_good_y = oy;
      last_good_z = oz;
      last_good_time = now;

      return true;

    } catch (...) 
    {
      if (useHoldLast()) return true;
      return false;
    }
  };

  int hold_cycles = 0;

  // 메인 루프
  // - 10Hz로 돌면서
  // - 마커를 보이면 STABILIZE/APPROACH/GRASP...
  // - 안 보이면 SEARCH(waypoint 이동)
  rclcpp::Rate rate(10);

  while (rclcpp::ok()) 
  {
    bool used_hold = false;

    // TF로부터 현재 마커 위치를 가져온다.
    // visible = true면 mx,my,mz가 업데이트 된 상태.
    bool visible = getFreshMarker(mx, my, mz, used_hold);

    if (visible && used_hold) hold_cycles++;
    else hold_cycles = 0;

    if (hold_cycles > hold_max_cycles) {
      stable_count = 0;
      fx.clear(); fy.clear(); fz.clear();
      state = FSM::SEARCH;
      rate.sleep();
      continue;
    }

    switch (state) 
    {
      // SEARCH: 마커를 찾기 위해 waypoint를 순회
      case FSM::SEARCH: 
      {
        stable_count = 0;
        fx.clear(); fy.clear(); fz.clear(); // 필터 초기화

        if (visible && !used_hold) 
        {
          RCLCPP_INFO(node->get_logger(), ">> Marker seen. Switching to STABILIZE");
          state = FSM::STABILIZE;
          break;
        }

        RCLCPP_INFO(node->get_logger(), ">> SEARCH waypoint %d", wp_idx);
        arm.setJointValueTarget(waypoints[wp_idx]);
        arm.move();

        wp_idx = (wp_idx + 1) % waypoints.size();
        rclcpp::sleep_for(300ms);
        break;
      }

      case FSM::STABILIZE: 
      {
        if (!visible) 
        {
          stable_count = 0;
          RCLCPP_WARN(node->get_logger(), ">> Lost marker. Back to SEARCH");
          state = FSM::SEARCH;
          break;
        }

        if (!used_hold) {
          stable_count++;
        }

        RCLCPP_INFO(node->get_logger(),
                    ">> STABILIZE %d/%d (x=%.3f y=%.3f z=%.3f)",
                    stable_count, stable_need, mx, my, mz);

        if (stable_count >= stable_need) 
        {
          current_offset = hover_offset;
          approach_fail = 0;
          RCLCPP_INFO(node->get_logger(), ">> STABILIZE done. Switching to APPROACH");
          state = FSM::APPROACH;
        }
        break;
      }

      case FSM::APPROACH: 
      {
        if (!visible) 
        {
          RCLCPP_WARN(node->get_logger(), ">> Lost marker during approach. Back to STABILIZE");
          stable_count = 0;
          state = FSM::STABILIZE;
          break;
        }

        if (used_hold) {
          rate.sleep();
          break;
        }

        double target_z = std::max(final_min_z, mz + current_offset);

        RCLCPP_INFO(node->get_logger(),
                    ">> APPROACH offset=%.3f target=(%.3f, %.3f, %.3f)",
                    current_offset, mx, my, target_z);

        arm.setStartStateToCurrentState();

        arm.setPositionTarget(mx, my, target_z);

        auto result = arm.move();

        if (result == moveit::core::MoveItErrorCode::SUCCESS) 
        {
          approach_fail = 0;

          current_offset -= step;

          if (current_offset <= 0.01) 
          {
            RCLCPP_INFO(node->get_logger(), ">> Reached near target. Switching to GRASP");
            state = FSM::GRASP;
          }
        } else 
        {
          approach_fail++;
          RCLCPP_ERROR(node->get_logger(), "Move failed (%d/%d).", approach_fail, max_fail_before_search);

          if (approach_fail >= max_fail_before_search) 
          {
            RCLCPP_WARN(node->get_logger(), ">> Too many failures. Back to SEARCH");
            state = FSM::SEARCH;
          } else 
          {
            current_offset = std::min(hover_offset, current_offset + 0.05);
          }
        }
        break;
      }

      case FSM::GRASP: 
      {
        RCLCPP_INFO(node->get_logger(), ">> GRASPING!");
        operateGripper(node, gripper, GRIP_CLOSE);
        state = FSM::LIFT_AND_HOME;
        break;
      }

      case FSM::LIFT_AND_HOME: 
      {
        double lift_z = std::max(final_min_z + 0.10, mz + hover_offset);
        RCLCPP_INFO(node->get_logger(), ">> LIFT to z=%.3f then HOME", lift_z);

        arm.setStartStateToCurrentState();
        arm.setPositionTarget(mx, my, lift_z);
        arm.move();

        arm.setNamedTarget("home");
        arm.move();

        operateGripper(node, gripper, GRIP_OPEN);

        RCLCPP_INFO(node->get_logger(), ">> Done. Switching to SEARCH");
        state = FSM::SEARCH;
        break;
      }
    }

    rate.sleep();
  }

  // 종료 처리
  rclcpp::shutdown();
  spinner.join();
  return 0;
}
