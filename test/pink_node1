// real_pick_node.cpp
// 흐름(부드럽게):
// 1) detect marker
// 2) tf base <- marker
// 3) compute grasp_pose (orientation align + approach vector)
// 4) move to pregrasp
// 5) cartesian approach
// 6) settle
// 7) close gripper (wait result)
// 8) retreat cartesian
// 9) move home
//
// ✅ 포인트
// - CENTER에서 move()를 반복 호출하는 “덜컥거림” 제거 (서보 안 씀)
// - 마커 pose 기반으로 pregrasp/grasp/retreat를 한 번에 계산
// - approach/retreat는 computeCartesianPath로 짧고 부드럽게
// - 그리퍼는 결과를 기다리는 blocking 방식
// - 마커 TF는 EMA 필터로 흔들림 완화
//
// ⚠️ 반드시 튜닝해야 하는 것 2개
// (A) EE가 마커를 향하도록 맞추는 offset_rpy (GRASP_R/P/Y)
// (B) 마커 프레임에서 "접근 방향"이 어디인지 (APPROACH_DIR_MARKER)
//     - 일반적으로 ArUco 프레임 z축이 마커 평면의 법선(밖으로)인 경우가 많지만 패키지/프레임 정의에 따라 다릅니다.
//     - 방향이 반대로 느껴지면 APPROACH_DIR_MARKER 부호를 뒤집으세요.

#include <rclcpp/rclcpp.hpp>
#include <rclcpp_action/rclcpp_action.hpp>

#include <control_msgs/action/gripper_command.hpp>
#include <moveit/move_group_interface/move_group_interface.h>

#include <tf2_ros/transform_listener.h>
#include <tf2_ros/buffer.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>

#include <geometry_msgs/msg/transform_stamped.hpp>
#include <geometry_msgs/msg/pose.hpp>

#include <ros2_aruco_interfaces/msg/aruco_markers.hpp>

#include <moveit_msgs/msg/robot_trajectory.hpp>

#include <chrono>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>
#include <cmath>
#include <string>

using namespace std::chrono_literals;

using GripperCommand = control_msgs::action::GripperCommand;
using ArucoMarkers   = ros2_aruco_interfaces::msg::ArucoMarkers;

static double clamp(double v, double lo, double hi) { return std::max(lo, std::min(hi, v)); }
static bool isFinite(double v) { return std::isfinite(v); }

static double dist3(const geometry_msgs::msg::Point& a, const geometry_msgs::msg::Point& b) {
  const double dx = a.x - b.x;
  const double dy = a.y - b.y;
  const double dz = a.z - b.z;
  return std::sqrt(dx*dx + dy*dy + dz*dz);
}

template<typename FutureT>
static bool waitFuture(const std::shared_ptr<rclcpp::Node>& node, FutureT& fut,
                       std::chrono::milliseconds timeout)
{
  const auto t0 = node->get_clock()->now();
  while (rclcpp::ok()) {
    if (fut.wait_for(50ms) == std::future_status::ready) return true;
    if ((node->get_clock()->now() - t0).seconds() > timeout.count()/1000.0) return false;
    rclcpp::sleep_for(10ms);
  }
  return false;
}

static bool operateGripperBlocking(const std::shared_ptr<rclcpp::Node>& node,
                                   const rclcpp_action::Client<GripperCommand>::SharedPtr& client,
                                   double pos, double effort,
                                   std::chrono::milliseconds timeout = 3000ms)
{
  if (!client->wait_for_action_server(2s)) {
    RCLCPP_ERROR(node->get_logger(), "Gripper action server not available");
    return false;
  }

  GripperCommand::Goal goal;
  goal.command.position   = pos;
  goal.command.max_effort = effort;

  auto gh_fut = client->async_send_goal(goal);
  if (!waitFuture(node, gh_fut, 1500ms)) {
    RCLCPP_ERROR(node->get_logger(), "Gripper goal send timeout");
    return false;
  }
  auto gh = gh_fut.get();
  if (!gh) {
    RCLCPP_ERROR(node->get_logger(), "Gripper goal rejected");
    return false;
  }

  auto res_fut = client->async_get_result(gh);
  if (!waitFuture(node, res_fut, timeout)) {
    RCLCPP_ERROR(node->get_logger(), "Gripper result timeout");
    return false;
  }

  auto wrapped = res_fut.get();
  if (wrapped.code != rclcpp_action::ResultCode::SUCCEEDED) {
    RCLCPP_ERROR(node->get_logger(), "Gripper action failed (code=%d)", (int)wrapped.code);
    return false;
  }

  const auto& res = *(wrapped.result);
  RCLCPP_INFO(node->get_logger(),
              "Gripper result: pos=%.4f effort=%.3f reached=%d stalled=%d",
              res.position, res.effort, (int)res.reached_goal, (int)res.stalled);

  // 물체를 집으면 "stalled"로 나오는 경우도 많음
  return (res.reached_goal || res.stalled || true);
}

// --------- simple pose EMA filter ----------
struct PoseFilterEMA {
  bool initialized{false};
  double alpha_pos{0.25}; // 0~1, 높을수록 빨리 따라감(덜 부드러움)
  double alpha_rot{0.25};

  tf2::Vector3 p;
  tf2::Quaternion q;

  static tf2::Quaternion slerp(const tf2::Quaternion& a, const tf2::Quaternion& b, double t) {
    tf2::Quaternion qa = a.normalized();
    tf2::Quaternion qb = b.normalized();
    // tf2에는 slerp가 없어서 geometry_msgs 변환으로 처리하거나 직접 구현.
    // 여기서는 간단히 "shortest path" 보정 후, tf2::Quaternion::slerp 사용(지원됨).
    // (지원 안 되는 빌드면 이 줄에서 컴파일 에러가 날 수 있음 → 그 경우 아래 주석의 대체 구현 사용)
    return qa.slerp(qb, t).normalized();
  }

  void update(const tf2::Vector3& p_in, const tf2::Quaternion& q_in) {
    if (!initialized) {
      p = p_in;
      q = q_in.normalized();
      initialized = true;
      return;
    }
    p = p*(1.0 - alpha_pos) + p_in*alpha_pos;
    q = slerp(q, q_in, alpha_rot);
  }
};

enum class FSM {
  HOME_INIT,
  WAIT_MARKER,
  PLAN_GRASP,            // tf(base<-marker) + pose 계산
  MOVE_PREGRASP,
  CART_APPROACH,
  SETTLE,
  GRASP_CLOSE_WAIT,
  CART_RETREAT,
  MOVE_HOME
};

int main(int argc, char** argv) {
  rclcpp::init(argc, argv);
  auto node = std::make_shared<rclcpp::Node>("real_pick_node");

  // spinner thread (action/sub 콜백)
  auto exec = std::make_shared<rclcpp::executors::SingleThreadedExecutor>();
  exec->add_node(node);
  std::thread spinner([&exec](){ exec->spin(); });

  // TF
  auto tf_buffer   = std::make_unique<tf2_ros::Buffer>(node->get_clock());
  auto tf_listener = std::make_shared<tf2_ros::TransformListener>(*tf_buffer);

  // MoveIt
  moveit::planning_interface::MoveGroupInterface arm(node, "arm");
  arm.setPlanningTime(4.0);
  arm.setMaxVelocityScalingFactor(0.15);     // ✅ 부드럽게(느리게)
  arm.setMaxAccelerationScalingFactor(0.15); // ✅ 부드럽게(느리게)
  arm.setGoalPositionTolerance(0.008);
  arm.setGoalOrientationTolerance(0.10);     // 너무 빡세면 플래닝 실패/떨림

  // Gripper
  auto gripper = rclcpp_action::create_client<GripperCommand>(
      node, "/gripper_controller/gripper_cmd");

  // -------- settings --------
  const std::string base_frame = "link1";
  const std::string markers_topic = "/aruco/markers";

  // 그리퍼 값(환경마다 다름)
  const double GRIP_OPEN   = 0.019;
  const double GRIP_CLOSE  = -0.001;
  const double GRIP_EFFORT = 8.0; // 약하면 더 올려라(실기구에 맞춰)

  // TF freshness
  const double max_tf_age_sec = 0.6;

  // marker selection bounds (from /aruco/markers)
  const double marker_z_min = 0.05;
  const double marker_z_max = 2.00;

  // 접근/그랩 파라미터
  const double grasp_offset_along_approach = 0.025; // 마커 기준 접근축으로 얼마나 떨어진 지점이 '그랩'인지
  const double pregrasp_dist = 0.12;                // 그랩 지점에서 뒤로 빠진 위치
  const double retreat_dist  = 0.12;                // 잡은 뒤 뒤로 빠지는 거리

  // Cartesian
  const double cart_step     = 0.005; // ✅ 더 촘촘 → 부드럽고 성공률↑(너무 작으면 느려짐)
  const double cart_jump_th  = 0.0;
  const double min_cart_frac = 0.90;

  // settle
  const auto settle_time = 300ms;

  // workspace clamp (안전)
  const double x_min = -0.35, x_max = 0.35;
  const double y_min = -0.35, y_max = 0.35;
  const double z_min =  0.05, z_max = 0.40;

  // 실패 처리
  int fail_count = 0;
  const int max_fail = 3;

  // ---------- marker cache ----------
  std::mutex mk_mtx;
  ArucoMarkers latest;
  bool have_markers = false;

  auto sub = node->create_subscription<ArucoMarkers>(
    markers_topic, 10,
    [&](const ArucoMarkers::SharedPtr msg){
      std::lock_guard<std::mutex> lk(mk_mtx);
      latest = *msg;
      have_markers = true;
    }
  );

  auto selectClosestMarkerId = [&]() -> int {
    std::lock_guard<std::mutex> lk(mk_mtx);
    if (!have_markers) return -1;
    if (latest.marker_ids.size() != latest.poses.size()) return -1;
    if (latest.marker_ids.empty()) return -1;

    int best_id = -1;
    double best_z = 1e9;
    for (size_t i = 0; i < latest.marker_ids.size(); i++) {
      const double z = latest.poses[i].position.z;
      if (!isFinite(z) || z < marker_z_min || z > marker_z_max) continue;
      if (z < best_z) {
        best_z = z;
        best_id = latest.marker_ids[i];
      }
    }
    return best_id;
  };

  auto getFreshTF = [&](const std::string& target, const std::string& source,
                        geometry_msgs::msg::TransformStamped& out) -> bool
  {
    try {
      if (!tf_buffer->canTransform(target, source, tf2::TimePointZero, 80ms))
        return false;

      auto t = tf_buffer->lookupTransform(target, source, tf2::TimePointZero);

      rclcpp::Time now   = node->get_clock()->now();
      rclcpp::Time stamp = rclcpp::Time(t.header.stamp);
      const double age = (now - stamp).seconds();
      if (age > max_tf_age_sec) return false;

      const auto &tr = t.transform.translation;
      if (!isFinite(tr.x) || !isFinite(tr.y) || !isFinite(tr.z)) return false;

      out = t;
      return true;
    } catch (...) {
      return false;
    }
  };

  // ====== orientation align ======
  // EE(그리퍼) 프레임이 마커를 "정면"으로 보도록 맞추는 오프셋.
  // ✅ 이 값은 네 로봇 EE 프레임 정의에 따라 거의 100% 튜닝 필요.
  // 튜닝 방법: 마커 앞에 로봇을 놓고, "정면으로 잡기 좋은 EE 자세"를 수동으로 만든 뒤,
  // 그때의 base<-marker, base<-ee 회전을 비교해서 오프셋을 추정.
  const double GRASP_ROLL  = M_PI;        // 예시
  const double GRASP_PITCH = 0.0;         // 예시
  const double GRASP_YAW   = M_PI / 2.0;  // 예시

  tf2::Quaternion q_marker_to_ee_offset;
  q_marker_to_ee_offset.setRPY(GRASP_ROLL, GRASP_PITCH, GRASP_YAW);
  q_marker_to_ee_offset.normalize();

  // ====== approach direction in marker frame ======
  // 보통: 마커 프레임의 +Z가 법선(카메라/로봇 쪽)인 경우가 많음.
  // 방향이 반대면 (0,0,-1)로 바꾸면 됨.
  const tf2::Vector3 APPROACH_DIR_MARKER(0.0, 0.0, 1.0);

  // EMA filter for marker pose in base frame
  PoseFilterEMA marker_filter;
  marker_filter.alpha_pos = 0.25;
  marker_filter.alpha_rot = 0.25;

  // ===== FSM vars =====
  FSM state = FSM::HOME_INIT;

  int target_id = -1;
  std::string target_frame;

  geometry_msgs::msg::Pose pregrasp_pose;
  geometry_msgs::msg::Pose grasp_pose;
  geometry_msgs::msg::Pose retreat_pose;

  // for approach success check
  const double grasp_pos_tol = 0.02;

  rclcpp::Rate rate(10);

  while (rclcpp::ok()) {
    switch (state) {

      case FSM::HOME_INIT: {
        RCLCPP_INFO(node->get_logger(), ">> HOME_INIT: go home + gripper open");
        arm.setNamedTarget("home");
        arm.move();
        rclcpp::sleep_for(300ms);

        (void)operateGripperBlocking(node, gripper, GRIP_OPEN, GRIP_EFFORT, 2500ms);

        fail_count = 0;
        target_id = -1;
        target_frame.clear();
        marker_filter.initialized = false;

        state = FSM::WAIT_MARKER;
        break;
      }

      case FSM::WAIT_MARKER: {
        const int best = selectClosestMarkerId();
        if (best < 0) {
          RCLCPP_INFO_THROTTLE(node->get_logger(), *node->get_clock(), 1500,
                               ">> WAIT_MARKER: no marker yet");
          break;
        }

        if (best != target_id) {
          target_id = best;
          target_frame = "aruco_marker_" + std::to_string(target_id);
          marker_filter.initialized = false;
          RCLCPP_INFO(node->get_logger(), ">> Target marker set: ID=%d (%s)",
                      target_id, target_frame.c_str());
        }

        // base <- marker 가 신선하면 grasp 계산으로
        geometry_msgs::msg::TransformStamped t_base_marker;
        if (!getFreshTF(base_frame, target_frame, t_base_marker)) {
          RCLCPP_WARN_THROTTLE(node->get_logger(), *node->get_clock(), 1000,
                               ">> WAIT_MARKER: TF not ready/fresh");
          break;
        }

        state = FSM::PLAN_GRASP;
        break;
      }

      case FSM::PLAN_GRASP: {
        if (target_frame.empty()) {
          state = FSM::WAIT_MARKER;
          break;
        }

        geometry_msgs::msg::TransformStamped t_base_marker;
        if (!getFreshTF(base_frame, target_frame, t_base_marker)) {
          state = FSM::WAIT_MARKER;
          break;
        }

        // Transform -> tf2
        tf2::Vector3 p_m(t_base_marker.transform.translation.x,
                         t_base_marker.transform.translation.y,
                         t_base_marker.transform.translation.z);

        tf2::Quaternion q_m;
        tf2::fromMsg(t_base_marker.transform.rotation, q_m);
        q_m.normalize();

        // EMA filter (마커 흔들림 완화)
        marker_filter.update(p_m, q_m);
        p_m = marker_filter.p;
        q_m = marker_filter.q;

        // approach direction in base
        tf2::Vector3 approach_dir_base = tf2::quatRotate(q_m, APPROACH_DIR_MARKER);
        const double n = approach_dir_base.length();
        if (n < 1e-6) {
          RCLCPP_ERROR(node->get_logger(), "Approach dir invalid");
          state = FSM::WAIT_MARKER;
          break;
        }
        approach_dir_base /= n; // normalize

        // orientation align
        // base<-ee = (base<-marker) * (marker<-ee_offset)
        tf2::Quaternion q_ee = (q_m * q_marker_to_ee_offset).normalized();

        // grasp position = marker position + approach_dir * offset
        tf2::Vector3 p_grasp = p_m + approach_dir_base * grasp_offset_along_approach;
        tf2::Vector3 p_pre   = p_grasp - approach_dir_base * pregrasp_dist;
        tf2::Vector3 p_ret   = p_grasp - approach_dir_base * (-retreat_dist); // p_grasp + approach_dir*retreat

        // clamp workspace (안전)
        p_grasp.setX(clamp(p_grasp.x(), x_min, x_max));
        p_grasp.setY(clamp(p_grasp.y(), y_min, y_max));
        p_grasp.setZ(clamp(p_grasp.z(), z_min, z_max));

        p_pre.setX(clamp(p_pre.x(), x_min, x_max));
        p_pre.setY(clamp(p_pre.y(), y_min, y_max));
        p_pre.setZ(clamp(p_pre.z(), z_min, z_max));

        p_ret.setX(clamp(p_ret.x(), x_min, x_max));
        p_ret.setY(clamp(p_ret.y(), y_min, y_max));
        p_ret.setZ(clamp(p_ret.z(), z_min, z_max));

        // fill poses
        pregrasp_pose.position.x = p_pre.x();
        pregrasp_pose.position.y = p_pre.y();
        pregrasp_pose.position.z = p_pre.z();
        pregrasp_pose.orientation = tf2::toMsg(q_ee);

        grasp_pose.position.x = p_grasp.x();
        grasp_pose.position.y = p_grasp.y();
        grasp_pose.position.z = p_grasp.z();
        grasp_pose.orientation = tf2::toMsg(q_ee);

        retreat_pose.position.x = p_ret.x();
        retreat_pose.position.y = p_ret.y();
        retreat_pose.position.z = p_ret.z();
        retreat_pose.orientation = tf2::toMsg(q_ee);

        RCLCPP_INFO(node->get_logger(),
          ">> PLAN_GRASP\n"
          "   marker=(%.3f %.3f %.3f)\n"
          "   pre   =(%.3f %.3f %.3f)\n"
          "   grasp =(%.3f %.3f %.3f)\n"
          "   ret   =(%.3f %.3f %.3f)\n"
          "   approach_dir_base=(%.3f %.3f %.3f)",
          p_m.x(), p_m.y(), p_m.z(),
          p_pre.x(), p_pre.y(), p_pre.z(),
          p_grasp.x(), p_grasp.y(), p_grasp.z(),
          p_ret.x(), p_ret.y(), p_ret.z(),
          approach_dir_base.x(), approach_dir_base.y(), approach_dir_base.z()
        );

        state = FSM::MOVE_PREGRASP;
        break;
      }

      case FSM::MOVE_PREGRASP: {
        RCLCPP_INFO(node->get_logger(), ">> MOVE_PREGRASP: plan+execute (pose target)");
        arm.setStartStateToCurrentState();
        arm.setPoseTarget(pregrasp_pose);

        auto res = arm.move();
        if (res != moveit::core::MoveItErrorCode::SUCCESS) {
          fail_count++;
          RCLCPP_ERROR(node->get_logger(), "MOVE_PREGRASP failed (%d/%d)", fail_count, max_fail);
          if (fail_count >= max_fail) state = FSM::HOME_INIT;
          else state = FSM::WAIT_MARKER;
          break;
        }

        fail_count = 0;
        state = FSM::CART_APPROACH;
        break;
      }

      case FSM::CART_APPROACH: {
        RCLCPP_INFO(node->get_logger(), ">> CART_APPROACH: computeCartesianPath to grasp");

        std::vector<geometry_msgs::msg::Pose> waypoints;
        waypoints.push_back(grasp_pose);

        moveit_msgs::msg::RobotTrajectory traj;
        arm.setStartStateToCurrentState();
        const double frac = arm.computeCartesianPath(waypoints, cart_step, cart_jump_th, traj);

        RCLCPP_INFO(node->get_logger(), ">> Approach fraction=%.2f", frac);
        if (frac < min_cart_frac) {
          fail_count++;
          RCLCPP_ERROR(node->get_logger(), "Approach cartesian too low (%.2f) (%d/%d)",
                       frac, fail_count, max_fail);
          if (fail_count >= max_fail) state = FSM::HOME_INIT;
          else state = FSM::WAIT_MARKER;
          break;
        }

        moveit::planning_interface::MoveGroupInterface::Plan plan;
        plan.trajectory_ = traj;

        auto exec_res = arm.execute(plan);
        if (exec_res != moveit::core::MoveItErrorCode::SUCCESS) {
          fail_count++;
          RCLCPP_ERROR(node->get_logger(), "Approach execute failed (%d/%d)", fail_count, max_fail);
          if (fail_count >= max_fail) state = FSM::HOME_INIT;
          else state = FSM::WAIT_MARKER;
          break;
        }

        // 도착 확인
        auto ee = arm.getCurrentPose().pose;
        const double err = dist3(ee.position, grasp_pose.position);
        RCLCPP_INFO(node->get_logger(), ">> EE pos err=%.3f", err);

        if (err > grasp_pos_tol) {
          fail_count++;
          RCLCPP_WARN(node->get_logger(), ">> Not close enough to grasp pose (%.3f).", err);
          if (fail_count >= max_fail) state = FSM::HOME_INIT;
          else state = FSM::WAIT_MARKER;
          break;
        }

        state = FSM::SETTLE;
        break;
      }

      case FSM::SETTLE: {
        RCLCPP_INFO(node->get_logger(), ">> SETTLE: %ld ms", settle_time.count());
        rclcpp::sleep_for(settle_time);
        state = FSM::GRASP_CLOSE_WAIT;
        break;
      }

      case FSM::GRASP_CLOSE_WAIT: {
        RCLCPP_INFO(node->get_logger(), ">> GRASP: close gripper (blocking)");
        const bool ok = operateGripperBlocking(node, gripper, GRIP_CLOSE, GRIP_EFFORT, 3500ms);
        if (!ok) {
          fail_count++;
          RCLCPP_ERROR(node->get_logger(), "Gripper close failed (%d/%d)", fail_count, max_fail);
          if (fail_count >= max_fail) state = FSM::HOME_INIT;
          else state = FSM::WAIT_MARKER;
          break;
        }
        fail_count = 0;
        state = FSM::CART_RETREAT;
        break;
      }

      case FSM::CART_RETREAT: {
        RCLCPP_INFO(node->get_logger(), ">> CART_RETREAT: computeCartesianPath to retreat");

        std::vector<geometry_msgs::msg::Pose> waypoints;
        waypoints.push_back(retreat_pose);

        moveit_msgs::msg::RobotTrajectory traj;
        arm.setStartStateToCurrentState();
        const double frac = arm.computeCartesianPath(waypoints, cart_step, cart_jump_th, traj);

        RCLCPP_INFO(node->get_logger(), ">> Retreat fraction=%.2f", frac);
        if (frac < min_cart_frac) {
          // 리트릿 실패해도 홈은 보내는 게 안전한 경우가 많음
          RCLCPP_WARN(node->get_logger(), "Retreat cartesian low (%.2f). Continue to home.", frac);
        } else {
          moveit::planning_interface::MoveGroupInterface::Plan plan;
          plan.trajectory_ = traj;
          (void)arm.execute(plan);
        }

        state = FSM::MOVE_HOME;
        break;
      }

      case FSM::MOVE_HOME: {
        RCLCPP_INFO(node->get_logger(), ">> MOVE_HOME: go home");
        arm.setNamedTarget("home");
        arm.move();

        // 다음 사이클 준비
        marker_filter.initialized = false;
        fail_count = 0;
        state = FSM::WAIT_MARKER;
        break;
      }
    }

    rate.sleep();
  }

  rclcpp::shutdown();
  spinner.join();
  return 0;
}
